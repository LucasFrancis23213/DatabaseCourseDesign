## 开发前应注意的事项
> 我们是三组并行开发，所以我在每一部份为各组分配了各自的代码空间  

> 关于文档中数据库表名、属性名与C#数据类和数据库中表名和属性名的转换关系：例如，文档中数据表名为UserInfo，存在属性UserID,SenderUserID,TimeStamp那么在C#和SQL的数据库表名为User_ID(**两个单词中间加了个下划线**)；属性名为User_ID,Sender_User_ID,Time_Stamp  

> 写一个类的具体实现前，先想好这个类的接口是什么，接口中的函数要做什么，把这些想明白了之后再写接口的具体实现，然后再把开发文档写了  

> 如果文件夹中有一个"logo.png"图片，他只是为了让文件夹非空存在的，只要确保该文件夹有其他的文件即可将logo.png删除  

- 韩敬霄组**只可以**在 **CommunityFeature..** 文件夹中做进一步的代码空间分配，**也只能把代码写在这个文件夹下**
- 陆诚彬组**只可以**在 **BasicFeature..** 文件夹中做进一步的代码空间分配，**也只能把代码写在这个文件夹下**  
- 朱雨凝组**只可以**在 **ManagementFeature..** 文件夹中做进一步的代码空间分配，**也只能把代码写在这个文件夹下**  
## SQLOperation
> 控制台应用，主要负责处理**访问数据库，后端业务逻辑，设计并存储数据类**  

### DataAccessLayer
> 数据访问层，用于直接和数据库交互，执行SQL语句(insert,delete...)
### BusinessLogicLayer
> 业务逻辑层，负责将从数据库读取的数据转化为相应的数据类(例如table a 有b,c,d三个属性，我要从a中读取某条件下的b,c,d属性，那么在执行完query语句后你会得到一个json序列化的一个列表(list)，这时你要在业务逻辑层代码中实例化一个class a(Utilities/DataCollection.cs中会提前创建好所有可能用到的数据类，其成员变量名、数据类型与数据库表中的完全一致)"，然后为a的成员变量b,c,d赋值为从数据库中读取的数据，**在此之后的操作都是针对这个数据类实例**)  

> 同理如果要写入数据，就是把上面的操作反过来就ok了  

> 执行其他的业务逻辑  
### ServiceLayer
> 服务层，他**只从BusinessLogicLayer**获取方法，对**DataAccessLayer层透明**，在本层**不应该去调用DataAccessLayer层的方法**，实现更高级别的封装  

### PublicAccess
> 公开文件夹，存放各组用于测试的接口、增删查改以及数据库连接的模板、以用户身份访问数据库的模板、数据库表对应的数据类以及各组需要的其他数据结构(各组的在PublicAccess/Utilities/ )  

> 除了各组自己设计的数据结构，**其余内容非必要不修改**，**如果修改了必须告知负责人和组长**  

> 如果发现增删查改的模板不能满足当前的要求，则可以复写这些函数(模板接口写的是虚方法)  

## WebAppTest  
### APILayer  
> 对ServiceLayer进行封装，负责前后端通信，提供前端可以调用的api
### APITemplate  
> APILayer里应该放的代码的模板，**注意：创建的文件名必须是以"Controller"结尾**，要不然创建的类无法继承ControllerBase  

